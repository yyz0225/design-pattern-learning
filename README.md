# design-pattern-learning
design-pattern-learning

##设计模式学习笔记

一.设计模式七大原则
1.单一职责 一个类和方法应只负责某一项职责
2.接口隔离 一个类对另一个的依赖应建立在最小的接口上
3.依赖倒置 面向接口编程
4.里氏替换 所有使用基类的地方必须能透明的使用其子类;子类中尽量不要重写父类的方法,会破坏继承体系;适当的情况下,采用聚合,依赖和组合方式解决
5.开闭原则 对扩展开放对修改关闭
6.迪米特法则 最少知道原则,一个类应该对自己依赖的类知道的越少越好,只与直接朋友通信(成员变量,方法参数,方法返回值)
7.合成复用 尽量使用合成/聚合的方式,而不是继承


二.设计模式

5种创建型设计模式:   关注如何创建对象，将对象的创建和使用相分离，分为：单例模式、工厂方法模式、抽象工厂模式、原型模式、建造者模式
7种结构型设计模式：  关注如何组合各种对象获得更好、更灵活的结构，分为：适配器模式、桥接模式、组合模式、装饰器模式、代理模式、享元模式、外观模式
11种行为型设计模式： 涉及算法和对象间的职责分配，一组对象间协调完成一个整体的任务，分为：责任链模式、命令模式、解释器模式、迭代器模式、中介模式、
                    备忘录模式、观察者模式、模板方法模式、状态模式、策略模式、访问者模式
                    
1)5种创建型设计模式        
            
1.单例模式(8种) 一个类只有一个实例,提供单个的全局访问点
  饿汉式(静态常量)
  饿汉式(静态代码块)
  懒汉式(线程不安全)
  懒汉式(线程安全,同步方法)
  懒汉式(线程安全,同步代码块)
  双重校验锁
  静态内部类
  枚举类
  使用场景: 频繁使用和创建的对象、创建对象耗时或资源过多的对象(重量级对象)、工具类对象、频繁访问数据库或文件的对象(如数据源、session工厂等)
2.工厂方法模式 专门的工厂类来创建对象
  工厂方法模式(简单工厂模式、工厂方法模式、静态工厂方法模式)
3. 抽象工厂模式(简单工厂模式+工厂方法模式的整合,抽象出更加抽象的接口)
4.原型模式(原对象的克隆体,需要区分深拷贝和浅拷贝)  
  实现方式: 1.实现Cloneable接口,重写Object类的clone方法(浅拷贝,若要实现深拷贝,需要把依赖的对象一层层复制完毕即可)
           2.序列化与反序列化实现(深拷贝)
5.建造者模式(将复杂对象的创建过程封装起来,对外屏蔽具体的创建过程,对外提供一个build方法即可)   
  角色组成: product(产品)、抽象建造者(抽象类或接口)、具体建造者(建造步骤,以方法区分)、指挥者(director,负责串联具体建造流程)
  
  
2)7种结构型设计模式

1.适配器模式 让两个不兼容的类可以协调工作,称之为Adapter或Wrapper
  类的适配器模式 Adapter类,通过继承src类(被适配者),实现dest(目标对象)接口,实现src->dest的适配
  对象的适配器模式 Adapter类,通过聚合src类(被适配者),实现dest接口,实现src->dest的适配
  接口的适配器模式 Adapter类,通过继承一个实现src接口的抽象类,来实现自己想要实现的方法即可

2.桥接模式(基于类的最小设计原则,通过使用封装、聚合及继承等行为,让不同的类承担不同的职责.把抽象与实现行为分离开来,保证各个功能的独立性和扩展性)
  使用步骤: 定义一个聚合了目标接口的抽象类,此类中增加实例方法,仅是调用接口中的方法,通过继承抽象类的子类,重写接口方法和目标接口的实现类实现业务需求,达到将抽象类和
  目标接口桥接起来的作用,减少类爆炸
  注意:重点在于识别出两个独立变化的维度(抽象和接口)
  
  使用场景: 
    JDBC驱动程序; 
    银行转账(转账分类: 网上转账,柜台转账,ATM转账(抽象) 转账用户类型: 普通客户,银卡客户,金卡客户(接口));
    消息发送(消息类型: 即时消息,延时消息(抽象) 消息分类: 手机消息,QQ消息,微信消息,邮件消息等(接口));
    
3.装饰器模式(动态给对象增加新功能,也体现了OCP原则)
  使用步骤: 装饰器与被装饰者实现同一个接口或继承同一个抽象类,并持有被装饰对象的实例(或抽象),在装饰器类中,通过在调用原目标的方法基础之上,
  重写原方法并额外增加新功能
  
4.组合模式(部分-整体模式,依据树形结构来组合对象)
  包含对象: Component(抽象类或接口)、Leaf(叶子节点,没有子节点)、Composite(非叶子节点,继承或实现Component,实现子部件的相关操作,比如add,remove等)
  
5.外观模式(过程模式或门面模式,提供一个统一的访问入口,屏蔽其他子系统的细节)  

6.享元模式(Flyweight,运用共享技术有效的支持大量细粒度对象)
  使用场景: 系统底层开发,解决性能问题
  经典场景: String常量池、数据库连接池、缓冲池等等
  外部状态: 随环境改变而改变,不可共享的状态
  内部状态: 不随环境改变而改变,可共享的状态,一旦定义好之后就不可更改
  使用步骤: 享元角色(产品的抽象，定义外部状态)、具体的享觉角色(定义内部状态和如何使用外部状态)、享元工厂类(池,不包含不可共享角色)、不可共享角色

7.代理模式(通过代理对象访问目标对象,扩展目标对象的功能)
  分类: 静态代理、动态代理(jdk代理,接口代理)和Cglib代理
  使用场景: 静态代理(类似于装饰器模式);
           动态代理(基于接口实现的代理,代理对象不需要实现接口,被代理对象需要实现接口,借助Proxy类的newProxyInstance方法);
           Cglib代理(基于子类实现的代理,底层原理是通过字节码处理框架ASM来转换字节码,生成新的类);
  Cglib使用步骤: 1.1 引入ASM框架相关依赖包 asm.jar、asm-commons.jar、asm-tree.jar、cglib-2.2.jar
                1.2 在内存中动态的创建子类(不能为final,否则会包IllegalArgumentException)
                1.3 不会执行目标对象额外的业务方法(final/static修饰)  
  几种常见的代理模式变种: 防火墙代理; 缓存代理; 远程代理; 同步代理                    

3)11种行为型模式













   